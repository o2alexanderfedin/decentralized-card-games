---
phase: 03-drag-drop
plan: 04
type: execute
wave: 3
depends_on: ["03-02", "03-03"]
files_modified:
  - src/components/CardDndProvider/CardDndProvider.tsx
  - src/components/CardDndProvider/CardDndProvider.types.ts
  - src/components/CardDndProvider/CardDndProvider.test.tsx
  - src/components/CardDndProvider/index.ts
autonomous: true

must_haves:
  truths:
    - "CardDndProvider wraps children in DndContext with configured sensors and collision detection"
    - "Drag lifecycle callbacks (onDragStart, onDragEnd, onDragOver, onDragCancel) fire at correct times"
    - "CardDragOverlay is automatically included inside the provider"
    - "Multi-card selection state is managed within the provider"
    - "Haptic feedback fires on pickup/hover/drop when enabled"
  artifacts:
    - path: "src/components/CardDndProvider/CardDndProvider.tsx"
      provides: "DnD context provider assembling all DnD pieces"
      min_lines: 60
    - path: "src/components/CardDndProvider/CardDndProvider.types.ts"
      provides: "Provider props type"
      exports: ["CardDndProviderProps"]
  key_links:
    - from: "src/components/CardDndProvider/CardDndProvider.tsx"
      to: "@dnd-kit/core"
      via: "DndContext provider"
      pattern: "<DndContext"
    - from: "src/components/CardDndProvider/CardDndProvider.tsx"
      to: "src/components/CardDragOverlay/CardDragOverlay.tsx"
      via: "renders CardDragOverlay inside DndContext"
      pattern: "<CardDragOverlay"
    - from: "src/components/CardDndProvider/CardDndProvider.tsx"
      to: "src/hooks/useDragSensors.ts"
      via: "sensor configuration"
      pattern: "useDragSensors"
    - from: "src/components/CardDndProvider/CardDndProvider.tsx"
      to: "src/hooks/useHapticFeedback.ts"
      via: "haptic feedback on drag events"
      pattern: "useHapticFeedback"
---

<objective>
Create CardDndProvider that assembles DndContext, sensors, drag overlay, and lifecycle management into a single provider component.

Purpose: This is the top-level component developers wrap around their game board. It wires together sensors (Plan 01), DraggableCard (Plan 02), CardDragOverlay and DroppableZone (Plan 03) into a cohesive DnD system. Manages active card state, multi-card selection, haptic feedback, and exposes lifecycle callbacks.

Output: CardDndProvider component with multi-card drag support, haptic feedback integration, and tests.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-drag-drop/03-RESEARCH.md
@.planning/phases/03-drag-drop/03-01-SUMMARY.md
@.planning/phases/03-drag-drop/03-02-SUMMARY.md
@.planning/phases/03-drag-drop/03-03-SUMMARY.md

@src/types/dnd.ts
@src/hooks/useDragSensors.ts
@src/hooks/useHapticFeedback.ts
@src/components/CardDragOverlay/CardDragOverlay.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CardDndProvider component with lifecycle and multi-card support</name>
  <files>src/components/CardDndProvider/CardDndProvider.types.ts, src/components/CardDndProvider/CardDndProvider.tsx, src/components/CardDndProvider/index.ts</files>
  <action>
    1. Create `src/components/CardDndProvider/CardDndProvider.types.ts`:
       - Import types from `../../types` and `@dnd-kit/core`
       - `CardDndProviderProps`:
         - `children: ReactNode` -- game board content
         - `onDragStart?: (card: CardData, sourceZoneId?: string) => void`
         - `onDragOver?: (card: CardData, overZoneId: string) => void`
         - `onDragEnd?: (card: CardData, targetZoneId: string | null, sourceZoneId?: string) => void`
         - `onDragCancel?: () => void`
         - `onDropReject?: (card: CardData, targetZoneId: string) => void`
         - `collisionDetection?: CollisionDetection` -- default closestCorners
         - `autoScroll?: boolean` -- default false (card games typically fit viewport)
         - `sensorConfig?: SensorConfig`
         - `hapticFeedback?: boolean` -- default false
         - `previewMode?: DragPreviewMode` -- default 'original'
         - `selectedCards?: CardData[]` -- externally controlled multi-card selection
         - `invalidDropBehavior?: InvalidDropBehavior` -- default 'snap-back'

    2. Create `src/components/CardDndProvider/CardDndProvider.tsx`:
       - Import `DndContext`, `closestCorners`, `DragStartEvent`, `DragEndEvent`, `DragOverEvent` from `@dnd-kit/core`
       - Import `useDragSensors` from `../../hooks`
       - Import `useHapticFeedback` from `../../hooks`
       - Import `CardDragOverlay` from `../CardDragOverlay`
       - Import `DragItemData` from `../../types`

       Internal state:
       - `activeCard: CardData | null` -- currently dragged card
       - `activeSourceZoneId: string | undefined` -- where the drag started

       Lifecycle handlers:
       - `handleDragStart(event: DragStartEvent)`:
         - Extract card from `event.active.data.current` (typed as DragItemData)
         - Set activeCard state
         - Set activeSourceZoneId from data
         - Call haptic.onPickup()
         - Call props.onDragStart(card, sourceZoneId)

       - `handleDragOver(event: DragOverEvent)`:
         - If `event.over` exists, call haptic.onHover()
         - Call props.onDragOver with card and over zone id

       - `handleDragEnd(event: DragEndEvent)`:
         - Extract target zone id from `event.over?.id`
         - If target exists:
           - Check validation via over zone's data (accepts, onValidate)
           - If valid: call haptic.onDrop(), call props.onDragEnd(card, targetId, sourceId)
           - If invalid: call haptic.onReject(), call props.onDropReject(card, targetId)
         - If no target (dropped outside): call props.onDragEnd(card, null, sourceId)
         - Reset activeCard to null

       - `handleDragCancel()`:
         - Reset activeCard to null
         - Call props.onDragCancel()

       Render:
       ```tsx
       <DndContext
         sensors={sensors}
         collisionDetection={collisionDetection ?? closestCorners}
         onDragStart={handleDragStart}
         onDragOver={handleDragOver}
         onDragEnd={handleDragEnd}
         onDragCancel={handleDragCancel}
         autoScroll={autoScroll ?? false}
       >
         {children}
         <CardDragOverlay
           activeCard={activeCard}
           selectedCards={selectedCards}
           previewMode={previewMode}
         />
       </DndContext>
       ```

    3. Create `src/components/CardDndProvider/index.ts`:
       ```typescript
       export { CardDndProvider } from './CardDndProvider';
       export type { CardDndProviderProps } from './CardDndProvider.types';
       ```
  </action>
  <verify>
    - `npx tsc --noEmit` has no type errors
    - File exists with DndContext, sensor, and overlay integration
  </verify>
  <done>CardDndProvider assembles DndContext with sensors, overlay, lifecycle callbacks, haptic feedback, and multi-card selection support</done>
</task>

<task type="auto">
  <name>Task 2: Create CardDndProvider tests</name>
  <files>src/components/CardDndProvider/CardDndProvider.test.tsx</files>
  <action>
    Create `src/components/CardDndProvider/CardDndProvider.test.tsx`:

    Mock strategy:
    - Mock `@dnd-kit/core`: DndContext as a div that calls provided callbacks, closestCorners as identity fn
    - Mock `../CardDragOverlay`: CardDragOverlay as a div displaying activeCard
    - Mock `../../hooks`: useDragSensors returns empty array, useHapticFeedback returns mock functions

    Tests:
    1. "renders children inside DndContext" -- verify children appear in output
    2. "renders CardDragOverlay inside DndContext" -- verify overlay element exists
    3. "calls onDragStart with card data when drag begins" -- simulate DndContext.onDragStart with mock event containing DragItemData, verify callback receives card
    4. "calls onDragEnd with card and target zone when drag completes" -- simulate DndContext.onDragEnd with over={id: 'zone-1'}, verify callback
    5. "calls onDragEnd with null target when dropped outside" -- simulate with over=null
    6. "calls onDragCancel when drag is cancelled" -- simulate cancel event
    7. "calls onDragOver when hovering over a zone" -- simulate over event
    8. "sets activeCard to null after drag ends" -- verify CardDragOverlay receives null activeCard after end
    9. "passes selectedCards to CardDragOverlay" -- pass selectedCards prop, verify overlay receives them
    10. "passes sensorConfig to useDragSensors" -- verify hook called with config
    11. "uses closestCorners collision detection by default" -- verify DndContext receives closestCorners
    12. "disables autoScroll by default" -- verify autoScroll={false} passed to DndContext

    For tests that simulate DndContext callbacks: The mock DndContext component captures the callback props and exposes them so tests can call them directly with mock event objects.

    ```typescript
    // Mock DndContext that exposes callbacks for testing
    let capturedProps: any = {};
    vi.mock('@dnd-kit/core', () => ({
      DndContext: ({ children, ...props }: any) => {
        capturedProps = props;
        return <div data-testid="dnd-context">{children}</div>;
      },
      closestCorners: vi.fn(),
    }));
    ```
  </action>
  <verify>
    - `npx vitest run src/components/CardDndProvider/` passes all tests
    - `npx vitest run` -- all existing tests still pass
  </verify>
  <done>CardDndProvider has 12 tests covering rendering, lifecycle callbacks, multi-card selection, sensor config, and default behaviors</done>
</task>

</tasks>

<verification>
- `npx vitest run src/components/CardDndProvider/` passes all 12 tests
- `npx tsc --noEmit` -- zero type errors
- CardDndProvider renders DndContext with configured sensors
- Lifecycle callbacks fire with correct card data and zone IDs
- CardDragOverlay receives activeCard state from provider
- Multi-card selection passed through to overlay
- autoScroll defaults to false
- closestCorners is default collision detection
</verification>

<success_criteria>
- CardDndProvider wraps children in DndContext with Mouse+Touch+Keyboard sensors
- Active card state managed internally, exposed to CardDragOverlay
- All 5 lifecycle callbacks (start, over, end, cancel, reject) fire with strongly-typed card data
- Haptic feedback integrated into lifecycle when enabled
- Drop validation checked against zone data before calling onDragEnd vs onDropReject
- Multi-card selection support via selectedCards prop
- autoScroll defaults to false (card games fit viewport)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-drag-drop/03-04-SUMMARY.md`
</output>
