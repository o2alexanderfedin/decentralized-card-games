---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/components/Card/Card.tsx
  - src/components/Card/index.ts
  - src/components/index.ts
  - src/index.ts
  - src/components/Card/Card.test.tsx
autonomous: false

must_haves:
  truths:
    - "Card component renders any of 52 cards face-up or face-down"
    - "Card flips smoothly with 3D CSS transform animation"
    - "Click/tap on card triggers onClick with card identity"
    - "Controlled mode respects isFaceUp prop"
    - "Uncontrolled mode flips on click and exposes ref API"
    - "Card scales responsively within container"
  artifacts:
    - path: "src/components/Card/Card.tsx"
      provides: "Main Card component with flip animation"
      exports: ["Card"]
      min_lines: 100
    - path: "src/components/Card/index.ts"
      provides: "Card component barrel export"
      exports: ["Card", "CardFace", "CardBack"]
    - path: "src/index.ts"
      provides: "Library entry point"
      exports: ["Card", "parseCard", "SUITS", "RANKS"]
    - path: "src/components/Card/Card.test.tsx"
      provides: "Component tests"
      min_lines: 80
  key_links:
    - from: "src/components/Card/Card.tsx"
      to: "src/hooks/useCardFlip.ts"
      via: "useCardFlip import"
      pattern: "import.*useCardFlip.*from"
    - from: "src/components/Card/Card.tsx"
      to: "src/components/Card/CardFace.tsx"
      via: "CardFace import"
      pattern: "import.*CardFace.*from"
    - from: "src/components/Card/Card.tsx"
      to: "motion/react"
      via: "motion.div for animation"
      pattern: "import.*motion.*from.*motion/react"
---

<objective>
Integrate all components into the complete Card component with flip animation, event handling, and controlled/uncontrolled modes.

Purpose: Deliver the core Card component that satisfies Phase 1 requirements (FNDN-01 through FNDN-07, ANIM-01 through ANIM-04). This is the main deliverable of Phase 1.

Output:
- Complete Card component with 3D flip animation
- Support for both controlled and uncontrolled modes
- Full event handling (click, hover, focus, animation lifecycle)
- Library exports for npm consumption
- Test suite validating all functionality
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation---core-rendering/01-CONTEXT.md
@.planning/phases/01-foundation---core-rendering/01-RESEARCH.md
@.planning/phases/01-foundation---core-rendering/01-02-SUMMARY.md
@.planning/phases/01-foundation---core-rendering/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create main Card component</name>
  <files>src/components/Card/Card.tsx</files>
  <action>
Create the main Card component in src/components/Card/Card.tsx:

```typescript
import { forwardRef, useImperativeHandle, useState, useCallback, useMemo } from 'react';
import { motion } from 'motion/react';
import { useCardFlip, usePrefersReducedMotion } from '../../hooks';
import { parseCard, CardData } from '../../types';
import { PERSPECTIVE_VALUES, ASPECT_RATIOS } from '../../constants';
import { CardFace } from './CardFace';
import { CardBack } from './CardBack';
import type { CardProps, CardRef, CardClickData } from './Card.types';
import styles from './Card.module.css';

export const Card = forwardRef<CardRef, CardProps>((props, ref) => {
  const {
    card,
    isFaceUp: controlledFaceUp,
    colorScheme = 'two-color',
    aspectRatio = 'poker',
    perspective = 'moderate',
    spring = 'default',
    cardBack,
    onClick,
    onFlipStart,
    onFlipComplete,
    onHover,
    onFocus,
    className,
  } = props;

  // Implementation...
});
```

Implementation requirements:

1. **Controlled/Uncontrolled Detection:**
   ```typescript
   const isControlled = controlledFaceUp !== undefined;
   const [internalFaceUp, setInternalFaceUp] = useState(true);
   const faceUp = isControlled ? controlledFaceUp : internalFaceUp;
   ```

2. **Card Data Resolution:**
   ```typescript
   const cardData = useMemo(() => {
     if (typeof card === 'string') {
       return parseCard(card);
     }
     return card;
   }, [card]);
   ```

3. **Animation Hook Integration:**
   ```typescript
   const prefersReducedMotion = usePrefersReducedMotion();
   const { rotateY, frontOpacity, backOpacity } = useCardFlip({
     isFaceUp: faceUp,
     spring: prefersReducedMotion ? { stiffness: 1000, damping: 50 } : spring,
     onFlipComplete,
   });
   ```

4. **Imperative API for Uncontrolled Mode:**
   ```typescript
   useImperativeHandle(ref, () => ({
     flip: () => {
       if (!isControlled) {
         onFlipStart?.();
         setInternalFaceUp(prev => !prev);
       }
     },
     isFaceUp: () => faceUp,
   }), [isControlled, faceUp, onFlipStart]);
   ```

5. **Click Handler:**
   ```typescript
   const handleClick = useCallback(() => {
     if (!isControlled) {
       onFlipStart?.();
       setInternalFaceUp(prev => !prev);
     }
     if (onClick && cardData) {
       const clickData: CardClickData = { ...cardData, isFaceUp: faceUp };
       onClick(clickData);
     }
   }, [isControlled, onClick, cardData, faceUp, onFlipStart]);
   ```

6. **Render Structure (from RESEARCH.md Pattern 3):**
   ```tsx
   <div className={containerClasses} style={{ perspective }}>
     <motion.div
       className={cardClasses}
       style={{ rotateY }}
       onClick={handleClick}
       onMouseEnter={() => onHover?.(true)}
       onMouseLeave={() => onHover?.(false)}
       onFocus={() => onFocus?.(true)}
       onBlur={() => onFocus?.(false)}
       tabIndex={0}
       role="button"
       aria-label={cardData ? `${cardData.rank} of ${cardData.suit}` : 'Card'}
     >
       <motion.div className={styles.face + ' ' + styles.front} style={{ opacity: frontOpacity }}>
         <CardFace card={cardData || card} colorScheme={colorScheme} />
       </motion.div>
       <motion.div className={styles.face + ' ' + styles.back} style={{ opacity: backOpacity }}>
         <CardBack>{cardBack}</CardBack>
       </motion.div>
     </motion.div>
   </div>
   ```

CRITICAL:
- Use motion.div with style={{ rotateY }} where rotateY is a MotionValue
- Apply backface-visibility in CSS, not inline
- Handle Safari flickering with webkit prefixes (done in CSS)
- Add tabIndex and ARIA attributes for basic accessibility

Reference: RESEARCH.md patterns and code examples
  </action>
  <verify>
Manual testing:
- Card renders correctly for any valid card notation
- Clicking card flips it in uncontrolled mode
- Controlled mode only flips when isFaceUp prop changes
- Animation is smooth with spring physics
- Reduced motion preference shows instant flip
  </verify>
  <done>
- Card component supports all 52 cards
- Controlled and uncontrolled modes work correctly
- Flip animation uses motion values (no re-renders)
- Events fire correctly (onClick, onFlipStart, onFlipComplete)
- Accessibility attributes present (tabIndex, aria-label, role)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create barrel exports for library distribution</name>
  <files>src/components/Card/index.ts, src/components/index.ts, src/index.ts</files>
  <action>
Create barrel exports at each level:

1. **src/components/Card/index.ts:**
   ```typescript
   export { Card } from './Card';
   export { CardFace } from './CardFace';
   export { CardBack } from './CardBack';
   export type { CardProps, CardRef, CardClickData, ColorScheme, AspectRatio, Perspective } from './Card.types';
   ```

2. **src/components/index.ts:**
   ```typescript
   export * from './Card';
   ```

3. **src/index.ts (library entry point):**
   ```typescript
   // Components
   export { Card, CardFace, CardBack } from './components';
   export type { CardProps, CardRef, CardClickData, ColorScheme, AspectRatio, Perspective } from './components';

   // Types
   export { SUITS, RANKS, parseCard, formatCard } from './types';
   export type { Suit, Rank, CardData } from './types';

   // Constants
   export { SUIT_EMOJI, SUIT_COLORS_TWO, SUIT_COLORS_FOUR, SPRING_PRESETS, PERSPECTIVE_VALUES, ASPECT_RATIOS } from './constants';

   // Hooks (for advanced usage)
   export { useCardFlip, usePrefersReducedMotion } from './hooks';
   export type { UseCardFlipOptions, UseCardFlipReturn } from './hooks';
   ```

This provides:
- Default import: `import { Card } from '@decentralized-games/card-components'`
- Named imports for all public APIs
- Type exports for TypeScript users
  </action>
  <verify>
- `import { Card } from './src'` works
- All public types are accessible
- No circular dependency errors
  </verify>
  <done>
- Library has single entry point
- All public APIs exported
- Types exported for TypeScript consumers
  </done>
</task>

<task type="auto">
  <name>Task 3: Write component tests</name>
  <files>src/components/Card/Card.test.tsx</files>
  <action>
Create comprehensive tests in src/components/Card/Card.test.tsx:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { Card } from './Card';

describe('Card', () => {
  describe('rendering', () => {
    it('renders card face when isFaceUp is true', () => {
      render(<Card card="♠A" isFaceUp={true} />);
      expect(screen.getByText('A')).toBeInTheDocument();
      expect(screen.getByText('♠')).toBeInTheDocument();
    });

    it('renders card back when isFaceUp is false', () => {
      render(<Card card="♠A" isFaceUp={false} />);
      // Card back should be visible, front should be hidden via backface-visibility
    });

    it('handles string notation', () => {
      render(<Card card="♥K" isFaceUp={true} />);
      expect(screen.getByText('K')).toBeInTheDocument();
    });

    it('handles CardData object', () => {
      render(<Card card={{ suit: 'diamonds', rank: 'Q' }} isFaceUp={true} />);
      expect(screen.getByText('Q')).toBeInTheDocument();
    });
  });

  describe('controlled mode', () => {
    it('respects isFaceUp prop', () => {
      const { rerender } = render(<Card card="♠A" isFaceUp={true} />);
      // Face should be visible

      rerender(<Card card="♠A" isFaceUp={false} />);
      // Back should be visible
    });

    it('does not toggle on click when controlled', () => {
      const onClick = vi.fn();
      render(<Card card="♠A" isFaceUp={true} onClick={onClick} />);

      fireEvent.click(screen.getByRole('button'));
      expect(onClick).toHaveBeenCalledWith({ suit: 'spades', rank: 'A', isFaceUp: true });
    });
  });

  describe('uncontrolled mode', () => {
    it('toggles on click', async () => {
      render(<Card card="♠A" />);
      const button = screen.getByRole('button');

      // Initial state is face up
      fireEvent.click(button);
      // Should now be face down (animation pending)
    });

    it('exposes flip method via ref', () => {
      const ref = { current: null };
      render(<Card card="♠A" ref={ref} />);

      expect(ref.current?.isFaceUp()).toBe(true);
      ref.current?.flip();
      expect(ref.current?.isFaceUp()).toBe(false);
    });
  });

  describe('events', () => {
    it('calls onClick with card data', () => {
      const onClick = vi.fn();
      render(<Card card="♠A" isFaceUp={true} onClick={onClick} />);

      fireEvent.click(screen.getByRole('button'));
      expect(onClick).toHaveBeenCalledWith({
        suit: 'spades',
        rank: 'A',
        isFaceUp: true,
      });
    });

    it('calls onFlipStart when flip begins', () => {
      const onFlipStart = vi.fn();
      render(<Card card="♠A" onFlipStart={onFlipStart} />);

      fireEvent.click(screen.getByRole('button'));
      expect(onFlipStart).toHaveBeenCalled();
    });

    it('calls onHover on mouse enter/leave', () => {
      const onHover = vi.fn();
      render(<Card card="♠A" isFaceUp={true} onHover={onHover} />);

      fireEvent.mouseEnter(screen.getByRole('button'));
      expect(onHover).toHaveBeenCalledWith(true);

      fireEvent.mouseLeave(screen.getByRole('button'));
      expect(onHover).toHaveBeenCalledWith(false);
    });
  });

  describe('accessibility', () => {
    it('has correct ARIA label', () => {
      render(<Card card="♠A" isFaceUp={true} />);
      expect(screen.getByRole('button')).toHaveAttribute('aria-label', 'A of spades');
    });

    it('is focusable via tab', () => {
      render(<Card card="♠A" isFaceUp={true} />);
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('tabIndex', '0');
    });
  });

  describe('color schemes', () => {
    it('applies two-color scheme by default', () => {
      render(<Card card="♥K" isFaceUp={true} />);
      // Hearts should be red
    });

    it('applies four-color scheme when specified', () => {
      render(<Card card="♦Q" isFaceUp={true} colorScheme="four-color" />);
      // Diamonds should be blue
    });
  });
});
```

Add test setup file if needed (vitest.setup.ts with jsdom and testing-library/jest-dom).
  </action>
  <verify>
Run `npm test` and verify:
- All tests pass
- Coverage for Card component > 80%
- No warnings or errors
  </verify>
  <done>
- Tests cover rendering, controlled/uncontrolled modes, events, accessibility
- All tests pass
- Test coverage meets threshold
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Card component with 3D flip animation</what-built>
  <how-to-verify>
1. Create a test file or Storybook story (executor will set this up)
2. Render several cards: `<Card card="♠A" />`, `<Card card="♥K" />`, etc.
3. Click cards to verify flip animation:
   - Animation should be smooth and bouncy (spring physics)
   - Card should rotate in 3D with proper perspective
   - Front/back faces should be visible at correct times
4. Test controlled mode:
   - `<Card card="♠A" isFaceUp={false} />` should show back
   - Changing isFaceUp prop should trigger flip
5. Test responsive sizing:
   - Card should scale to fit container while maintaining aspect ratio
6. Test color schemes:
   - Two-color: hearts/diamonds red, spades/clubs black
   - Four-color: hearts red, diamonds blue, clubs green, spades black
  </how-to-verify>
  <resume-signal>Type "approved" if Card component works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full component structure exists:
   ```
   src/
     components/
       Card/
         Card.tsx
         CardFace.tsx
         CardBack.tsx
         Card.types.ts
         Card.module.css
         Card.test.tsx
         index.ts
       index.ts
     hooks/
       useCardFlip.ts
       usePrefersReducedMotion.ts
       index.ts
     types/
       card.ts
       index.ts
     constants/
       suits.ts
       animations.ts
       index.ts
     index.ts
   ```

2. `npm test` passes
3. `npx tsc --noEmit` passes
4. `npm run build` produces library output
5. Visual verification confirms smooth flip animation
</verification>

<success_criteria>
Phase 1 Requirements Satisfied:
- [FNDN-01] Render all 52 playing cards - Card accepts any suit/rank
- [FNDN-02] Face up/down state toggle - isFaceUp prop and flip functionality
- [FNDN-03] Card flip animation with CSS 3D transforms - motion.div with rotateY
- [FNDN-04] Click and tap event handlers - onClick with CardClickData
- [FNDN-05] TypeScript types - Suit, Rank, CardData, CardProps, CardRef
- [FNDN-06] Responsive sizing - aspect-ratio CSS with container-fit
- [FNDN-07] Basic container - Card component wraps faces
- [ANIM-01] GPU-accelerated animations - transform and opacity only
- [ANIM-02] Motion Values for animation state - useMotionValue, useSpring
- [ANIM-03] Configurable flip animation - spring presets
- [ANIM-04] No animation re-renders - motion values bypass React state
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation---core-rendering/01-04-SUMMARY.md`
</output>
