---
phase: 04-state-management
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/state/selectors.ts
  - src/state/selectors.test.ts
  - src/state/index.ts
  - src/hooks/useStateBackend.ts
  - src/hooks/useGameState.ts
  - src/hooks/useLocation.ts
  - src/hooks/useCard.ts
  - src/hooks/useGameActions.ts
  - src/hooks/useStateHooks.test.tsx
  - src/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "Selectors return cards at a location, a specific card by location+index, gamePhase, currentPlayer"
    - "useGameState returns full GameState"
    - "useLocation(locationId) returns CardState[] for that location"
    - "useCard(location, index) returns a single CardState or undefined"
    - "useGameActions returns a dispatch function accepting GameAction"
    - "All hooks throw if used outside a provider (StateBackendContext is null)"
  artifacts:
    - path: "src/state/selectors.ts"
      provides: "Pure selector functions on GameState"
      exports: ["selectLocation", "selectCard", "selectGamePhase", "selectCurrentPlayer", "selectAllLocations"]
    - path: "src/hooks/useStateBackend.ts"
      provides: "StateBackend interface and context used by both providers"
      exports: ["StateBackend", "StateBackendContext", "useStateBackend"]
    - path: "src/hooks/useGameState.ts"
      provides: "Hook returning full game state"
      exports: ["useGameState"]
    - path: "src/hooks/useLocation.ts"
      provides: "Hook returning cards at a location"
      exports: ["useLocation"]
    - path: "src/hooks/useCard.ts"
      provides: "Hook returning individual card"
      exports: ["useCard"]
    - path: "src/hooks/useGameActions.ts"
      provides: "Hook returning dispatch function"
      exports: ["useGameActions"]
  key_links:
    - from: "src/hooks/useGameState.ts"
      to: "src/hooks/useStateBackend.ts"
      via: "useStateBackend() to get state"
      pattern: "useStateBackend"
    - from: "src/hooks/useLocation.ts"
      to: "src/state/selectors.ts"
      via: "selectLocation selector"
      pattern: "selectLocation"
    - from: "src/hooks/useGameActions.ts"
      to: "src/hooks/useStateBackend.ts"
      via: "useStateBackend() to get dispatch"
      pattern: "useStateBackend"
---

<objective>
Create pure selectors, the StateBackend abstraction, and all four unified hooks (useGameState, useLocation, useCard, useGameActions).

Purpose: The StateBackend interface is the strategy pattern pivot -- both Context mode (04-03) and Redux mode (04-04) will populate it. Hooks read from StateBackend, so they work identically regardless of which provider is above them. Selectors provide reusable data access functions used by hooks and consumers.

Output: `src/state/selectors.ts` with tests, `src/hooks/useStateBackend.ts`, four hook files, hook tests using a mock StateBackend provider.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-state-management/04-CONTEXT.md
@.planning/phases/04-state-management/04-RESEARCH.md
@.planning/phases/04-state-management/04-01-SUMMARY.md
@src/state/types.ts
@src/state/reducer.ts
@src/hooks/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pure selectors on GameState</name>
  <files>src/state/selectors.ts, src/state/selectors.test.ts, src/state/index.ts</files>
  <action>
Create `src/state/selectors.ts` -- pure functions operating on GameState (no RTK imports):

1. `selectAllLocations(state: GameState): Record<string, CardState[]>` -- returns state.locations
2. `selectLocation(state: GameState, locationId: string): CardState[]` -- returns `state.locations[locationId] ?? []`
3. `selectCard(state: GameState, location: string, cardIndex: number): CardState | undefined` -- returns `state.locations[location]?.[cardIndex]`
4. `selectGamePhase(state: GameState): string | null` -- returns state.gamePhase
5. `selectCurrentPlayer(state: GameState): string | null` -- returns state.currentPlayer
6. `selectLocationCount(state: GameState, locationId: string): number` -- returns length of cards at location

Create `src/state/selectors.test.ts`:
- Test each selector with a sample GameState
- Test selectLocation returns empty array for missing location
- Test selectCard returns undefined for out-of-bounds index

Update `src/state/index.ts` to re-export all selectors.
  </action>
  <verify>`npx vitest run src/state/selectors.test.ts` -- all selector tests pass.</verify>
  <done>Six pure selectors exported and tested. No RTK imports. Barrel export updated.</done>
</task>

<task type="auto">
  <name>Task 2: StateBackend interface and unified hooks</name>
  <files>src/hooks/useStateBackend.ts, src/hooks/useGameState.ts, src/hooks/useLocation.ts, src/hooks/useCard.ts, src/hooks/useGameActions.ts, src/hooks/useStateHooks.test.tsx, src/hooks/index.ts</files>
  <action>
Create `src/hooks/useStateBackend.ts`:

1. Define `StateBackend` interface:
   ```typescript
   export interface StateBackend {
     getState: () => GameState;
     dispatch: (action: GameAction) => void;
     subscribe: (listener: () => void) => () => void;
   }
   ```
2. Create `StateBackendContext = createContext<StateBackend | null>(null)`
3. Export `useStateBackend()` hook that reads from context and throws if null:
   `throw new Error('useStateBackend must be used within a GameStateProvider or ReduxGameProvider')`

Create four hooks (each in its own file):

**`src/hooks/useGameState.ts`:**
- Uses `useSyncExternalStore(backend.subscribe, backend.getState)` for tear-safe reads
- Returns `GameState`

**`src/hooks/useLocation.ts`:**
- Takes `locationId: string` parameter
- Uses useSyncExternalStore + selectLocation selector
- Returns `CardState[]` (memoized via useMemo comparing the specific location reference)

**`src/hooks/useCard.ts`:**
- Takes `location: string, cardIndex: number`
- Uses useSyncExternalStore + selectCard selector
- Returns `CardState | undefined`

**`src/hooks/useGameActions.ts`:**
- Returns the dispatch function from StateBackend (stable reference)
- Return type: `(action: GameAction) => void`

Create `src/hooks/useStateHooks.test.tsx`:
- Create a `MockStateBackendProvider` test helper that wraps children in StateBackendContext.Provider with a mock backend (getState returns fixed state, dispatch is vi.fn(), subscribe is vi.fn() returning unsubscribe).
- Test useGameState returns full state
- Test useLocation('hand') returns cards at 'hand' location
- Test useLocation('nonexistent') returns empty array
- Test useCard('hand', 0) returns first card
- Test useCard('hand', 99) returns undefined
- Test useGameActions returns dispatch function; calling it invokes backend.dispatch
- Test all hooks throw when used outside provider

Update `src/hooks/index.ts` to export:
- useStateBackend, StateBackend, StateBackendContext
- useGameState, useLocation, useCard, useGameActions
  </action>
  <verify>`npx vitest run src/hooks/useStateHooks.test.tsx` -- all hook tests pass. `npx tsc --noEmit` -- no type errors.</verify>
  <done>StateBackend interface defined. Four unified hooks work with mock provider. All hooks throw outside provider. Barrel exports updated.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/state/selectors.test.ts src/hooks/useStateHooks.test.tsx` -- all tests pass
2. `npx tsc --noEmit` -- no type errors
3. `grep -r "@reduxjs/toolkit" src/state/ src/hooks/useStateBackend.ts src/hooks/useGame*.ts src/hooks/useLocation.ts src/hooks/useCard.ts` -- returns nothing
4. Hooks use useSyncExternalStore for tear-safe reads
5. StateBackend interface is the single abstraction both providers will implement
</verification>

<success_criteria>
- All selectors tested and exported
- StateBackend interface defined with getState/dispatch/subscribe
- Four hooks (useGameState, useLocation, useCard, useGameActions) tested with mock provider
- All hooks throw descriptive error when used outside provider
- No RTK imports in any hook or selector file
</success_criteria>

<output>
After completion, create `.planning/phases/04-state-management/04-02-SUMMARY.md`
</output>
