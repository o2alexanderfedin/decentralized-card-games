---
phase: 04-state-management
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - src/redux/slice.ts
  - src/redux/store.ts
  - src/redux/ReduxGameProvider.tsx
  - src/redux/selectors.ts
  - src/redux/ReduxGameProvider.test.tsx
  - src/redux/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "createSlice wraps the shared reducer with Immer-powered mutations"
    - "configureGameStore() returns a fully configured Redux store"
    - "ReduxGameProvider populates StateBackendContext so unified hooks work"
    - "Redux-specific memoized selectors handle location/card selection"
    - "@reduxjs/toolkit and react-redux are optional peer dependencies"
    - "All RTK imports are strictly confined to src/redux/ directory"
  artifacts:
    - path: "src/redux/slice.ts"
      provides: "createSlice with all game actions"
      exports: ["gameSlice", "moveCard", "flipCard", "dealCards", "reset"]
    - path: "src/redux/store.ts"
      provides: "configureGameStore helper and type exports"
      exports: ["configureGameStore", "GameStore", "GameRootState", "GameDispatch"]
    - path: "src/redux/ReduxGameProvider.tsx"
      provides: "Redux-backed provider that populates StateBackend"
      exports: ["ReduxGameProvider"]
    - path: "src/redux/selectors.ts"
      provides: "Memoized Redux selectors with createSelector"
      exports: ["selectLocation", "selectCard", "selectGamePhase"]
    - path: "src/redux/index.ts"
      provides: "Separate entry point for Redux users"
  key_links:
    - from: "src/redux/slice.ts"
      to: "src/state/initialState.ts"
      via: "Uses createInitialState for slice initial state"
      pattern: "createInitialState"
    - from: "src/redux/ReduxGameProvider.tsx"
      to: "src/hooks/useStateBackend.ts"
      via: "Populates StateBackendContext.Provider"
      pattern: "StateBackendContext\\.Provider"
    - from: "src/redux/ReduxGameProvider.tsx"
      to: "src/redux/store.ts"
      via: "Uses Redux store for state backend"
      pattern: "configureGameStore|useStore"
---

<objective>
Create the Redux Toolkit entry point: slice, store helper, ReduxGameProvider, and memoized selectors.

Purpose: Redux users get a complete package -- configureGameStore() for quick setup, gameSlice for manual store integration, ReduxGameProvider that plugs into the same hook system as Context mode. All RTK imports are strictly confined to src/redux/ so non-Redux users never encounter them.

Output: `src/redux/` directory as the separate entry point, with slice, store, provider, selectors, and tests.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-state-management/04-CONTEXT.md
@.planning/phases/04-state-management/04-RESEARCH.md
@.planning/phases/04-state-management/04-01-SUMMARY.md
@.planning/phases/04-state-management/04-02-SUMMARY.md
@src/state/types.ts
@src/state/initialState.ts
@src/hooks/useStateBackend.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Redux deps, create slice and store</name>
  <files>src/redux/slice.ts, src/redux/store.ts, src/redux/selectors.ts, package.json</files>
  <action>
**Install dependencies:**
- `npm install --save-dev @reduxjs/toolkit react-redux` (devDependencies for building/testing)
- These will also be listed as optional peerDependencies in package.json

**Update `package.json`:**
Add to peerDependencies (alongside existing react/react-dom):
```json
"@reduxjs/toolkit": "^2.0.0",
"react-redux": "^9.0.0"
```
Add peerDependenciesMeta:
```json
"peerDependenciesMeta": {
  "@reduxjs/toolkit": { "optional": true },
  "react-redux": { "optional": true }
}
```

**Create `src/redux/slice.ts`:**
- Import `createSlice`, `PayloadAction` from `@reduxjs/toolkit`
- Import all payload types from `../state/types`
- Import `createInitialState` from `../state/initialState`

Define `gameSlice = createSlice({...})`:
- name: `'cardGame'`
- initialState: `createInitialState()`
- reducers (Immer-powered mutations):
  - `moveCard(state, action: PayloadAction<MoveCardPayload>)` -- splice from source, push to target (init target array if undefined)
  - `flipCard(state, action: PayloadAction<FlipCardPayload>)` -- set faceUp on card
  - `selectCard(state, action: PayloadAction<SelectCardPayload>)` -- set selected on card
  - `setLocations(state, action: PayloadAction<SetLocationsPayload>)` -- merge locations
  - `setGamePhase(state, action: PayloadAction<string>)` -- set gamePhase
  - `setCurrentPlayer(state, action: PayloadAction<string>)` -- set currentPlayer
  - `dealCards(state, action: PayloadAction<DealCardsPayload>)` -- shift from source, push to targets
  - `shuffleLocation(state, action: PayloadAction<string>)` -- Fisher-Yates in-place shuffle
  - `reset(_state, action: PayloadAction<Partial<GameState> | undefined>)` -- return merged initial state
- selectors (built-in):
  - `selectLocations: (state) => state.locations`
  - `selectGamePhase: (state) => state.gamePhase`
  - `selectCurrentPlayer: (state) => state.currentPlayer`

Export `gameSlice`, all actions from `gameSlice.actions`, and `default gameSlice.reducer`.

**Create `src/redux/store.ts`:**
- Import `configureStore` from `@reduxjs/toolkit`
- Import `gameSlice` from `./slice`
- Import `createInitialState` from `../state/initialState`
- Import `GameState` type from `../state/types`

Export `configureGameStore(preloadedState?: Partial<GameState>)`:
```typescript
export function configureGameStore(preloadedState?: Partial<GameState>) {
  return configureStore({
    reducer: {
      [gameSlice.reducerPath]: gameSlice.reducer,
    },
    preloadedState: preloadedState
      ? { [gameSlice.reducerPath]: { ...createInitialState(), ...preloadedState } }
      : undefined,
  });
}
```

Export types:
- `GameStore = ReturnType<typeof configureGameStore>`
- `GameRootState = ReturnType<GameStore['getState']>`
- `GameDispatch = GameStore['dispatch']`

**Create `src/redux/selectors.ts`:**
- Import `createSelector` from `@reduxjs/toolkit`
- Import `GameRootState` from `./store`
- Import `gameSlice` from `./slice`

Memoized selectors for RootState:
- `selectGameState = (state: GameRootState) => state[gameSlice.reducerPath]`
- `makeSelectLocation(locationId: string)` -- factory returning memoized selector via createSelector
- `makeSelectCard(location: string, cardIndex: number)` -- factory returning memoized selector
- Re-export built-in selectors from gameSlice.selectors (wrapped for RootState)
  </action>
  <verify>`npx tsc --noEmit` -- no type errors. Verify @reduxjs/toolkit only imported in src/redux/ files.</verify>
  <done>Redux slice with all 9 action types, configureGameStore helper, memoized selectors. RTK confined to src/redux/.</done>
</task>

<task type="auto">
  <name>Task 2: ReduxGameProvider and integration tests</name>
  <files>src/redux/ReduxGameProvider.tsx, src/redux/ReduxGameProvider.test.tsx, src/redux/index.ts</files>
  <action>
**Create `src/redux/ReduxGameProvider.tsx`:**

1. Import `Provider` from `react-redux`.
2. Import `StateBackendContext` from `../hooks/useStateBackend`.
3. Import `configureGameStore`, `GameStore` from `./store`.
4. Import `gameSlice` from `./slice`.
5. Import `GameState`, `GameAction` types from `../state/types`.

Define `ReduxGameProviderProps`:
- `children: React.ReactNode`
- `store?: GameStore` -- optional pre-configured store (for advanced users)
- `initialState?: Partial<GameState>` -- used if no store provided

Implementation:
- If `store` prop is provided, use it. Otherwise, create one with `configureGameStore(initialState)`.
- Use `useMemo` to store the store reference.
- Create the StateBackend adapter that bridges Redux store to the StateBackend interface. The dispatch adapter accepts `(type, payload)` per user's Redux-style API decision and maps to slice action creators:
  ```typescript
  const backend: StateBackend = useMemo(() => ({
    getState: () => reduxStore.getState()[gameSlice.reducerPath],
    dispatch: (type: string, payload?: Record<string, unknown>) => {
      // Map type strings to slice action creators
      // e.g., type === 'MOVE_CARD' -> reduxStore.dispatch(gameSlice.actions.moveCard(payload))
      const actionCreatorMap: Record<string, (p: any) => any> = {
        MOVE_CARD: gameSlice.actions.moveCard,
        FLIP_CARD: gameSlice.actions.flipCard,
        SELECT_CARD: gameSlice.actions.selectCard,
        SET_LOCATIONS: gameSlice.actions.setLocations,
        SET_GAME_PHASE: gameSlice.actions.setGamePhase,
        SET_CURRENT_PLAYER: gameSlice.actions.setCurrentPlayer,
        DEAL_CARDS: gameSlice.actions.dealCards,
        SHUFFLE_LOCATION: gameSlice.actions.shuffleLocation,
        RESET: gameSlice.actions.reset,
      };
      const creator = actionCreatorMap[type];
      if (creator) reduxStore.dispatch(creator(payload));
    },
    subscribe: (listener) => reduxStore.subscribe(listener),
  }), [reduxStore]);
  ```
- Render: `<Provider store={reduxStore}><StateBackendContext.Provider value={backend}>{children}</StateBackendContext.Provider></Provider>`

**Create `src/redux/ReduxGameProvider.test.tsx`:**

Integration tests proving unified hooks work with Redux backend:

1. **Hooks work with ReduxGameProvider:** Wrap test component in `<ReduxGameProvider>`. Use `useGameState()`, verify initial state.

2. **Dispatch via useGameActions:** Use `useGameActions` to get dispatch, call `dispatch('MOVE_CARD', { cardIndex: 0, from: 'deck', to: 'hand' })`. Verify `useLocation` reflects change.

3. **dealStandardDeck integration:** Call `dispatch('SET_LOCATIONS', { locations: { deck: [...52 cards] } })`. Verify `useLocation('deck')` returns 52 cards.

4. **Custom store prop:** Create store with `configureGameStore({ gamePhase: 'playing' })`. Pass as store prop. Verify useGameState reflects preloaded state.

5. **Custom initialState prop:** Pass `initialState={{ currentPlayer: 'Bob' }}` without store prop. Verify state.

6. **Redux useSelector still works:** Import `useSelector` from react-redux. Verify it reads from the same store.

**Create `src/redux/index.ts`** -- this is the SEPARATE ENTRY POINT:
- Export `gameSlice` and all actions from `./slice`
- Export `configureGameStore`, `GameStore`, `GameRootState`, `GameDispatch` from `./store`
- Export `ReduxGameProvider` from `./ReduxGameProvider`
- Export all selectors from `./selectors`
- Re-export shared types that Redux users need: `GameState`, `CardState`, `GameAction`, all payload types from `../state/types`
- Re-export `createInitialState` from `../state/initialState`
- Re-export all action creator functions from `../state/actions`
  </action>
  <verify>`npx vitest run src/redux/` -- all tests pass. `npx tsc --noEmit` -- no type errors.</verify>
  <done>ReduxGameProvider bridges Redux store to StateBackend. Unified hooks work identically with Redux backend. Separate entry point exports everything Redux users need.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/redux/` -- all tests pass
2. `npx tsc --noEmit` -- no type errors
3. `grep -r "@reduxjs/toolkit" src/ --include="*.ts" --include="*.tsx" | grep -v "src/redux/"` -- returns nothing (RTK confined to src/redux/)
4. ReduxGameProvider populates StateBackendContext
5. Unified hooks (useGameState, useLocation, useCard, useGameActions) work within ReduxGameProvider
6. configureGameStore returns working store with gameSlice
</verification>

<success_criteria>
- Redux slice handles all 9 action types with Immer mutations
- configureGameStore creates working store
- ReduxGameProvider bridges Redux to StateBackend interface
- Hooks work identically whether using GameProvider or ReduxGameProvider
- @reduxjs/toolkit and react-redux are optional peer dependencies
- All RTK imports strictly in src/redux/ directory
</success_criteria>

<output>
After completion, create `.planning/phases/04-state-management/04-04-SUMMARY.md`
</output>
