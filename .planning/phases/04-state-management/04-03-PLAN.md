---
phase: 04-state-management
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - src/context/GameContext.ts
  - src/context/persistence.ts
  - src/context/GameProvider.tsx
  - src/context/GameProvider.test.tsx
  - src/context/index.ts
autonomous: true

must_haves:
  truths:
    - "GameProvider wraps children and provides StateBackend via context"
    - "Hooks (useGameState, useLocation, useGameActions) work within GameProvider"
    - "State persists to localStorage and rehydrates on mount"
    - "Dispatch and state contexts are split to prevent unnecessary re-renders"
    - "GameProvider works without Redux installed -- no RTK imports"
  artifacts:
    - path: "src/context/GameProvider.tsx"
      provides: "Standalone context provider using useReducer + localStorage"
      exports: ["GameProvider"]
    - path: "src/context/persistence.ts"
      provides: "localStorage load/save helpers"
      exports: ["loadState", "saveState"]
    - path: "src/context/GameContext.ts"
      provides: "Context type exports and GameProviderProps"
      exports: ["GameProviderProps"]
    - path: "src/context/index.ts"
      provides: "Barrel exports for context module"
  key_links:
    - from: "src/context/GameProvider.tsx"
      to: "src/hooks/useStateBackend.ts"
      via: "Populates StateBackendContext.Provider"
      pattern: "StateBackendContext\\.Provider"
    - from: "src/context/GameProvider.tsx"
      to: "src/state/reducer.ts"
      via: "Uses gameReducer with useReducer"
      pattern: "useReducer.*gameReducer"
    - from: "src/context/GameProvider.tsx"
      to: "src/context/persistence.ts"
      via: "Loads/saves state from localStorage"
      pattern: "loadState|saveState"
---

<objective>
Create the standalone Context mode provider with localStorage persistence.

Purpose: This enables the library to work without Redux. GameProvider uses React's useReducer with the shared pure reducer, populates the StateBackend context so all unified hooks work, and persists state to localStorage for page refresh survival.

Output: `src/context/` directory with GameProvider, persistence helpers, and integration tests proving hooks work end-to-end.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-state-management/04-CONTEXT.md
@.planning/phases/04-state-management/04-RESEARCH.md
@.planning/phases/04-state-management/04-01-SUMMARY.md
@.planning/phases/04-state-management/04-02-SUMMARY.md
@src/state/types.ts
@src/state/reducer.ts
@src/state/initialState.ts
@src/hooks/useStateBackend.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: localStorage persistence helpers</name>
  <files>src/context/persistence.ts, src/context/GameContext.ts</files>
  <action>
Create `src/context/persistence.ts`:

1. Define `STORAGE_KEY = 'cardGameState'` constant.
2. Export `loadState(): GameState | undefined`:
   - Try `localStorage.getItem(STORAGE_KEY)`
   - If found, `JSON.parse()` and return as GameState
   - Wrap in try/catch -- return undefined on any error (corrupt data, private browsing)
3. Export `saveState(state: GameState): void`:
   - Try `localStorage.setItem(STORAGE_KEY, JSON.stringify(state))`
   - Wrap in try/catch -- silently fail on quota exceeded
4. Export `clearState(): void`:
   - Try `localStorage.removeItem(STORAGE_KEY)`

Create `src/context/GameContext.ts`:

1. Define `GameProviderProps` interface:
   - `children: React.ReactNode`
   - `initialState?: Partial<GameState>` -- optional state override
   - `persist?: boolean` -- enable localStorage persistence (default: true)
   - `storageKey?: string` -- custom localStorage key (default: 'cardGameState')
  </action>
  <verify>`npx tsc --noEmit` -- no type errors.</verify>
  <done>Persistence helpers handle localStorage read/write with error handling. GameProviderProps defined.</done>
</task>

<task type="auto">
  <name>Task 2: GameProvider component and integration tests</name>
  <files>src/context/GameProvider.tsx, src/context/GameProvider.test.tsx, src/context/index.ts</files>
  <action>
Create `src/context/GameProvider.tsx`:

1. Import `useReducer`, `useEffect`, `useCallback`, `useRef`, `useMemo` from React.
2. Import `gameReducer` from `../state/reducer`.
3. Import `createInitialState` from `../state/initialState`.
4. Import `StateBackendContext` from `../hooks/useStateBackend`.
5. Import `loadState`, `saveState` from `./persistence`.
6. Import `GameProviderProps` from `./GameContext`.

Implementation:
- Compute initial state: if `persist` is true, try `loadState()`, merge with `createInitialState()` and `initialState` prop overrides.
- Use `useReducer(gameReducer, computedInitialState)`.
- Create a `stateRef = useRef(state)` updated on each render (for getState in subscribe pattern).
- Create a `listenersRef = useRef(new Set<() => void>())` for subscribers.
- In a useEffect after state changes: notify all listeners, and if persist is true, call `saveState(state)`.
- Build the StateBackend object with `useMemo`. The dispatch adapter converts `dispatch(type, payload)` calls into GameAction objects for useReducer:
  ```typescript
  const backend: StateBackend = useMemo(() => ({
    getState: () => stateRef.current,
    dispatch: (type: string, payload?: Record<string, unknown>) => {
      // Construct GameAction from type + payload and pass to useReducer's dispatch
      rawDispatch({ type, payload } as GameAction);
    },
    subscribe: (listener) => { listeners.add(listener); return () => listeners.delete(listener); },
  }), []);
  ```
  Where `rawDispatch` is the dispatch from `useReducer(gameReducer, computedInitialState)`.
- Render `<StateBackendContext.Provider value={backend}>{children}</StateBackendContext.Provider>`.

Key considerations:
- The subscribe/getState pattern is required for useSyncExternalStore in the hooks.
- The dispatch adapter bridges `dispatch('MOVE_CARD', { cardIndex, from, to })` to the pure reducer's GameAction format.
- Call listeners in a useEffect triggered by state changes (not synchronously in reducer).

Create `src/context/GameProvider.test.tsx`:

Integration tests proving hooks work end-to-end with GameProvider:

1. **Render with default state:** Wrap a test component using `useGameState()` in `<GameProvider>`. Verify state has empty locations, null gamePhase, null currentPlayer.

2. **Dispatch moveCard:** Setup initial state with cards in 'deck'. Use `useGameActions` to get dispatch, call `dispatch('MOVE_CARD', { cardIndex: 0, from: 'deck', to: 'hand' })`. Verify `useLocation('hand')` reflects the moved card.

3. **dealStandardDeck integration:** Import `dealStandardDeck` action creator to get the action, then dispatch via `dispatch('SET_LOCATIONS', { locations: ... })`. Verify `useLocation('deck')` returns 52 cards.

4. **localStorage persistence:** Mount GameProvider with persist=true and initial cards. Verify `saveState` was called (mock localStorage). Unmount and remount -- verify state rehydrates from localStorage.

5. **persist=false disables localStorage:** Mount with persist=false. Dispatch action. Verify localStorage was NOT written to.

6. **Custom initialState prop:** Pass `initialState={{ currentPlayer: 'Alice', gamePhase: 'dealing' }}`. Verify useGameState reflects overrides.

Create `src/context/index.ts` barrel:
- Export GameProvider from './GameProvider'
- Export GameProviderProps from './GameContext'
- Export loadState, saveState, clearState from './persistence'
  </action>
  <verify>`npx vitest run src/context/` -- all integration tests pass. `npx tsc --noEmit` -- no type errors. `grep -r "@reduxjs/toolkit" src/context/` returns nothing.</verify>
  <done>GameProvider works with useReducer + shared reducer. Hooks work end-to-end within GameProvider. localStorage persistence saves and rehydrates state. No RTK imports.</done>
</task>

</tasks>

<verification>
1. `npx vitest run src/context/` -- all tests pass
2. `npx tsc --noEmit` -- no type errors
3. `grep -r "@reduxjs/toolkit" src/context/` -- returns nothing
4. GameProvider populates StateBackendContext so hooks work
5. localStorage persistence is optional (persist prop)
6. State rehydrates from localStorage on mount
</verification>

<success_criteria>
- GameProvider provides StateBackend to all hooks
- Hooks (useGameState, useLocation, useCard, useGameActions) work within GameProvider
- localStorage persistence saves on state change and rehydrates on mount
- persist=false disables localStorage
- No Redux imports anywhere in context mode code
</success_criteria>

<output>
After completion, create `.planning/phases/04-state-management/04-03-SUMMARY.md`
</output>
